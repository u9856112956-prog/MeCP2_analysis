#!/usr/bin/env python3
"""
Peak-Based MeCP2 Enrichment vs Gene Expression Correlation Analysis (DEA genes with significant MeCP2 enrichment)

This script analyzes the correlation between peak-based MeCP2 enrichment and gene expression changes.
It uses the peak enrichment data generated by peak_based_enrichment_analysis.py and correlates it with
RNA-seq differential expression data.

Key differences from the gene-body based analysis:
- Uses peak-based enrichment scores instead of full gene region signals
- Aggregates multiple peaks per gene (promoter and gene body separately)
- Applies the same normalization strategies as peak_based_enrichment_analysis.py
- Restricts to DEA genes with significant MeCP2 enrichment (p < threshold) in at least one peak region

Analysis approach:
1. Load peak enrichment data (detailed CSV from peak_based_enrichment_analysis.py)
2. Map peaks to genes using gene_id/gene_name annotations
3. Aggregate peak enrichment scores per gene (separately for promoter and gene body peaks)
4. Merge with DEA data
5. Filter to DEA genes with significant MeCP2 enrichment
6. Calculate correlations between peak enrichment and expression changes

Usage:
    python peak_based_expression_correlation_deaonly_significant.py \
        --peak-enrichment-dir /path/to/peak_based_enrichment_analysis/narrow_peaks \
        --dea-filtered-file /path/to/DEA_Neu_filtered.csv \
        --output-dir /path/to/output \
        --cell-type Neu \
        --normalization-method raw \
        --enrichment-pvalue-threshold 0.2
"""

import argparse
import logging
import math
from pathlib import Path
from typing import Dict, Tuple, List
import sys

import numpy as np
import pandas as pd
from scipy import stats

import matplotlib
matplotlib.use("Agg")
import matplotlib.pyplot as plt
import seaborn as sns

sns.set_style("whitegrid")

EPS = 1e-6

# Region type categories for peak aggregation
PEAK_REGION_CATEGORIES = {
    "promoter": "Promoter Peaks",
    "gene_body": "Gene Body Peaks",
}

SUBSET_DEFINITIONS = {
    "all_dea": lambda df: df,  # All DEA genes
    "upregulated": lambda df: df[df["log2FoldChange"] > 0],
    "downregulated": lambda df: df[df["log2FoldChange"] < 0],
}


def configure_logging(verbose: bool = False) -> None:
    level = logging.DEBUG if verbose else logging.INFO
    logging.basicConfig(
        level=level,
        format="%(asctime)s - %(levelname)s - %(message)s",
    )


def load_peak_enrichment_data(peak_enrichment_file: Path) -> pd.DataFrame:
    """Load peak enrichment detailed CSV file (annotated with genes)"""
    if not peak_enrichment_file.exists():
        raise FileNotFoundError(f"Peak enrichment file not found: {peak_enrichment_file}")

    logging.info(f"Loading peak enrichment data from {peak_enrichment_file}")
    df = pd.read_csv(peak_enrichment_file)

    logging.info(f"Loaded {len(df)} peaks")
    logging.info(f"Peak region types: {df['region_type'].value_counts().to_dict()}")

    return df


def load_dea_filtered_genes(path: Path) -> pd.DataFrame:
    """Load the DEA filtered genes file"""
    logging.info(f"Loading DEA filtered genes from {path}")
    df = pd.read_csv(path)

    # Ensure gene column is clean (remove version numbers)
    df["gene_clean"] = df["gene"].astype(str).str.replace(r"\.\d+$", "", regex=True)

    logging.info(f"Loaded {len(df)} DEA filtered genes")
    return df


def aggregate_peaks_to_genes(peak_df: pd.DataFrame, normalization_method: str) -> pd.DataFrame:
    """
    Aggregate peak-level enrichment to gene-level summaries

    For each gene, we calculate:
    - Mean/max enrichment for promoter peaks
    - Mean/max enrichment for gene body peaks
    - Number of peaks in each region type
    - Minimum p-value across peaks
    """
    # Filter peaks that have gene annotations
    # Use gene_name (symbol) for matching with DEA data, not gene_id (Ensembl ID)
    annotated_peaks = peak_df[peak_df['gene_name'].notna()].copy()

    if len(annotated_peaks) == 0:
        raise ValueError("No peaks have gene_name annotations. Check if annotation script ran successfully.")

    logging.info(f"Annotated peaks with gene names: {len(annotated_peaks)} / {len(peak_df)}")

    # Use gene_name as the identifier (this matches DEA file which uses gene symbols)
    annotated_peaks['gene_symbol'] = annotated_peaks['gene_name'].astype(str)

    # Determine which signal columns to use based on normalization
    if normalization_method == 'raw':
        exo_signal_col = 'exo_signal'
        endo_signal_col = 'endo_signal'
        enrichment_col = 'enrichment'
    else:
        exo_signal_col = 'exo_signal_norm'
        endo_signal_col = 'endo_signal_norm'
        enrichment_col = 'enrichment_norm'

    # Aggregate by gene and region type
    gene_summaries = []

    for gene_symbol in annotated_peaks['gene_symbol'].unique():
        gene_peaks = annotated_peaks[annotated_peaks['gene_symbol'] == gene_symbol]

        gene_summary = {
            'gene_symbol': gene_symbol,
            'total_peaks': len(gene_peaks),
        }

        # Aggregate for each region type
        for region_type in ['promoter', 'gene_body']:
            region_peaks = gene_peaks[gene_peaks['region_type'] == region_type]

            if len(region_peaks) > 0:
                # Replace inf values with NaN for proper aggregation
                region_peaks_clean = region_peaks.copy()
                region_peaks_clean[enrichment_col] = region_peaks_clean[enrichment_col].replace([np.inf, -np.inf], np.nan)

                gene_summary[f'{region_type}_n_peaks'] = len(region_peaks)
                gene_summary[f'{region_type}_mean_exo_signal'] = region_peaks[exo_signal_col].mean()
                gene_summary[f'{region_type}_mean_endo_signal'] = region_peaks[endo_signal_col].mean()
                gene_summary[f'{region_type}_max_exo_signal'] = region_peaks[exo_signal_col].max()
                gene_summary[f'{region_type}_max_endo_signal'] = region_peaks[endo_signal_col].max()
                gene_summary[f'{region_type}_mean_enrichment'] = region_peaks_clean[enrichment_col].mean()
                gene_summary[f'{region_type}_max_enrichment'] = region_peaks_clean[enrichment_col].max()
                gene_summary[f'{region_type}_min_pvalue'] = region_peaks['pvalue'].min()
            else:
                gene_summary[f'{region_type}_n_peaks'] = 0
                gene_summary[f'{region_type}_mean_exo_signal'] = np.nan
                gene_summary[f'{region_type}_mean_endo_signal'] = np.nan
                gene_summary[f'{region_type}_max_exo_signal'] = np.nan
                gene_summary[f'{region_type}_max_endo_signal'] = np.nan
                gene_summary[f'{region_type}_mean_enrichment'] = np.nan
                gene_summary[f'{region_type}_max_enrichment'] = np.nan
                gene_summary[f'{region_type}_min_pvalue'] = np.nan

        gene_summaries.append(gene_summary)

    gene_level_df = pd.DataFrame(gene_summaries)
    logging.info(f"Aggregated {len(gene_level_df)} genes from peaks")

    # Log summary statistics
    for region_type in ['promoter', 'gene_body']:
        n_genes_with_peaks = (gene_level_df[f'{region_type}_n_peaks'] > 0).sum()
        logging.info(f"  Genes with {region_type} peaks: {n_genes_with_peaks}")

    return gene_level_df


def has_significant_mecp2_enrichment_peaks(row: pd.Series, pvalue_threshold: float = 0.5,
                                          enrichment_threshold: float = 1.2) -> bool:
    """
    Check if a gene has significant MeCP2 enrichment in at least one peak region

    Uses two criteria (OR logic):
    1. P-value threshold (e.g., <= 0.5 for binomial test)
    2. Enrichment threshold (exo/endo mean signal ratio > threshold, e.g., > 1.2)

    Returns True if EITHER criterion is met in promoter OR gene_body peaks

    Note: Binomial test p-values have minimum of 0.2 (1/5 or 1/3 replicates),
    so p-value threshold should be >= 0.2 to have any effect.
    """
    # Check p-values (if threshold is achievable)
    if pvalue_threshold >= 0.2:  # Only check if threshold is achievable
        pvalue_columns = [
            "promoter_min_pvalue",
            "gene_body_min_pvalue",
        ]

        for col in pvalue_columns:
            if col in row.index and pd.notna(row[col]) and row[col] <= pvalue_threshold:
                return True

    # Check enrichment ratios (mean exo/endo signal ratio)
    enrichment_columns = [
        ("promoter_mean_exo_signal", "promoter_mean_endo_signal"),
        ("gene_body_mean_exo_signal", "gene_body_mean_endo_signal"),
    ]

    for exo_col, endo_col in enrichment_columns:
        if exo_col in row.index and endo_col in row.index:
            if pd.notna(row[exo_col]) and pd.notna(row[endo_col]):
                if row[endo_col] > 0:  # Avoid division by zero
                    ratio = row[exo_col] / row[endo_col]
                    if ratio > enrichment_threshold:
                        return True

    return False


def merge_with_dea_and_filter(gene_level_df: pd.DataFrame, dea_df: pd.DataFrame,
                              enrichment_pvalue_threshold: float = 1.0,
                              enrichment_ratio_threshold: float = 0.0) -> pd.DataFrame:
    """
    Merge peak-based gene enrichment with DEA data and optionally filter by enrichment

    Filtering options:
    - enrichment_pvalue_threshold = 1.0 and enrichment_ratio_threshold = 0.0: No filtering (analyze ALL DEA genes with peaks)
    - enrichment_ratio_threshold > 0: Filter to genes with exo/endo ratio above threshold
    - enrichment_pvalue_threshold < 1.0: Filter to genes with p-value below threshold

    Note: For correlation analysis, filtering is typically NOT recommended as it reduces
    statistical power. The correlation itself will determine if enrichment predicts expression.

    Args:
        gene_level_df: Gene-level aggregated peak enrichment data
        dea_df: Differential expression analysis results
        enrichment_pvalue_threshold: P-value threshold (default 1.0 = no filtering)
        enrichment_ratio_threshold: Exo/Endo ratio threshold (default 0.0 = no filtering)
    """
    logging.info("Merging gene-level peak enrichment with DEA data")

    # Get DEA genes
    dea_genes = set(dea_df["gene_clean"].tolist())

    # Filter gene-level data to DEA genes
    dea_filtered = gene_level_df[gene_level_df['gene_symbol'].isin(dea_genes)].copy()
    logging.info(f"Filtered from {len(gene_level_df)} to {len(dea_filtered)} DEA genes")

    # Merge with DEA data to get expression changes
    merged_df = dea_filtered.merge(
        dea_df[['gene_clean', 'log2FoldChange', 'padj', 'baseMean']],
        left_on='gene_symbol',
        right_on='gene_clean',
        how='inner'
    )
    logging.info(f"Merged dataset: {len(merged_df)} genes")

    # Apply enrichment filtering only if thresholds are not default (no-filter) values
    if enrichment_pvalue_threshold < 1.0 or enrichment_ratio_threshold > 0.0:
        logging.info("Applying enrichment filtering...")
        enrichment_mask = merged_df.apply(
            lambda row: has_significant_mecp2_enrichment_peaks(
                row, enrichment_pvalue_threshold, enrichment_ratio_threshold
            ),
            axis=1
        )
        filtered_df = merged_df[enrichment_mask].copy()

        logging.info(f"Filtered from {len(merged_df)} to {len(filtered_df)} genes with significant MeCP2 enrichment")
        logging.info(f"  Criteria: p-value <= {enrichment_pvalue_threshold} OR exo/endo ratio > {enrichment_ratio_threshold}")

        if len(filtered_df) == 0:
            logging.warning("No genes found with significant MeCP2 enrichment. Consider:")
            logging.warning(f"  1. Increasing p-value threshold (current: {enrichment_pvalue_threshold})")
            logging.warning(f"  2. Decreasing enrichment ratio threshold (current: {enrichment_ratio_threshold})")
            logging.warning(f"  3. Using no filtering: --enrichment-pvalue-threshold 1.0 --enrichment-ratio-threshold 0.0")
            raise ValueError("No genes found with both DEA status and significant MeCP2 enrichment in peaks")
    else:
        # No filtering - use all DEA genes with peaks
        filtered_df = merged_df.copy()
        logging.info(f"No enrichment filtering applied - analyzing all {len(filtered_df)} DEA genes with peaks")
        logging.info(f"  (To enable filtering, set --enrichment-pvalue-threshold < 1.0 or --enrichment-ratio-threshold > 0.0)")

    return filtered_df


def compute_enrichment_metrics(merged_df: pd.DataFrame) -> pd.DataFrame:
    """
    Compute enrichment metrics for correlation analysis

    For each region type (promoter, gene_body), calculate:
    - log2 ratio of exo/endo signals
    - delta signal (endo - exo)
    """
    result_df = merged_df.copy()

    # Compute absolute log2FoldChange
    result_df['abs_log2FoldChange'] = result_df['log2FoldChange'].abs()

    for region_type in ['promoter', 'gene_body']:
        exo_col = f'{region_type}_mean_exo_signal'
        endo_col = f'{region_type}_mean_endo_signal'

        if exo_col in result_df.columns and endo_col in result_df.columns:
            # Log2 ratio
            result_df[f'{region_type}_log2_ratio'] = np.log2(
                (result_df[exo_col] + EPS) / (result_df[endo_col] + EPS)
            )

            # Delta signal
            result_df[f'{region_type}_delta_signal'] = result_df[endo_col] - result_df[exo_col]

    return result_df


def _compute_corr(x: pd.Series, y: pd.Series, method: str) -> Tuple[float, float]:
    """Compute correlation between two series"""
    valid = x.notna() & y.notna() & np.isfinite(x) & np.isfinite(y)
    x_valid = x[valid]
    y_valid = y[valid]

    if len(x_valid) < 3 or x_valid.nunique() < 2 or y_valid.nunique() < 2:
        return np.nan, np.nan

    if method == "pearson":
        corr, pval = stats.pearsonr(x_valid, y_valid)
    else:
        corr, pval = stats.spearmanr(x_valid, y_valid)
    return corr, pval


def _compute_regression(x: pd.Series, y: pd.Series) -> Tuple[float, float, float]:
    """Compute linear regression between two series"""
    valid = x.notna() & y.notna() & np.isfinite(x) & np.isfinite(y)
    x_valid = x[valid]
    y_valid = y[valid]

    if len(x_valid) < 3 or x_valid.nunique() < 2 or y_valid.nunique() < 2:
        return np.nan, np.nan, np.nan

    lr = stats.linregress(x_valid, y_valid)
    return lr.slope, lr.pvalue, lr.rvalue ** 2


def _fisher_ci(corr: float, n: int, alpha: float) -> Tuple[float, float]:
    """Compute Fisher's z-transformation confidence interval"""
    if not np.isfinite(corr) or n <= 3:
        return np.nan, np.nan

    corr = max(min(corr, 0.999999), -0.999999)
    z = np.arctanh(corr)
    se = 1 / math.sqrt(n - 3)
    z_crit = stats.norm.ppf(1 - alpha / 2)
    lower = np.tanh(z - z_crit * se)
    upper = np.tanh(z + z_crit * se)
    return lower, upper


def compute_peak_region_correlations(
    integrated_df: pd.DataFrame,
    method: str,
    alpha: float,
    min_genes: int,
) -> Tuple[pd.DataFrame, Dict[str, pd.DataFrame]]:
    """
    Compute correlations between peak-based enrichment and expression changes

    Similar to compute_region_correlations but for peak-aggregated data
    """
    records = []
    scatter_data: Dict[str, pd.DataFrame] = {}

    for region_type, label in PEAK_REGION_CATEGORIES.items():
        log2_ratio_col = f'{region_type}_log2_ratio'
        delta_signal_col = f'{region_type}_delta_signal'

        if log2_ratio_col not in integrated_df.columns:
            logging.warning(f"Skipping region {region_type}: required columns missing")
            continue

        # Prepare region-specific dataframe
        region_df = integrated_df[
            [log2_ratio_col, delta_signal_col, 'log2FoldChange', 'abs_log2FoldChange', 'padj']
        ].copy()

        region_df = region_df.replace([np.inf, -np.inf], np.nan).dropna(
            subset=['log2FoldChange', log2_ratio_col]
        )

        if region_df.empty:
            logging.warning(f"Skipping region {region_type}: no valid data after filtering")
            continue

        # Store for scatter plots
        scatter_data[region_type] = region_df[[log2_ratio_col, 'abs_log2FoldChange', 'log2FoldChange']].copy()

        # Compute correlations for each subset
        for subset_name, subset_fn in SUBSET_DEFINITIONS.items():
            subset = subset_fn(region_df).copy()
            subset = subset.dropna(subset=[log2_ratio_col, 'abs_log2FoldChange'])

            if len(subset) < min_genes:
                logging.debug(
                    f"Skipping region {region_type} subset {subset_name}: only {len(subset)} genes (min={min_genes})"
                )
                continue

            # Correlate with absolute log2FoldChange
            corr_ratio, p_ratio = _compute_corr(
                subset[log2_ratio_col], subset['abs_log2FoldChange'], method
            )
            corr_delta, p_delta = _compute_corr(
                subset[delta_signal_col], subset['abs_log2FoldChange'], method
            )
            slope, slope_p, r_sq = _compute_regression(
                subset[log2_ratio_col], subset['abs_log2FoldChange']
            )
            ci_lower, ci_upper = _fisher_ci(corr_ratio, len(subset), alpha)

            # Also compute correlation with signed log2FC
            corr_signed, p_signed = _compute_corr(
                subset[log2_ratio_col], subset['log2FoldChange'], method
            )

            records.append({
                "region": region_type,
                "region_label": label,
                "subset": subset_name,
                "n_genes": len(subset),
                "correlation_method": method,
                "correlation_log2_ratio_abs": corr_ratio,
                "pvalue_log2_ratio_abs": p_ratio,
                "correlation_log2_ratio_signed": corr_signed,
                "pvalue_log2_ratio_signed": p_signed,
                "correlation_delta_abs": corr_delta,
                "pvalue_delta_abs": p_delta,
                "fisher_ci_lower": ci_lower,
                "fisher_ci_upper": ci_upper,
                "linear_slope": slope,
                "linear_pvalue": slope_p,
                "r_squared": r_sq,
                "mean_log2_ratio": subset[log2_ratio_col].mean(),
                "mean_delta_signal": subset[delta_signal_col].mean(),
                "mean_abs_expression_log2FC": subset['abs_log2FoldChange'].mean(),
                "mean_signed_expression_log2FC": subset['log2FoldChange'].mean(),
            })

    results_df = pd.DataFrame(records)
    return results_df, scatter_data


def create_correlation_plot(
    results_df: pd.DataFrame,
    alpha: float,
    output_dir: Path,
    suffix: str,
) -> None:
    """Create correlation summary plot"""
    subset_df = results_df[results_df["subset"] == "all_dea"].copy()
    if subset_df.empty:
        logging.warning("No 'all_dea' subset correlations available; skipping summary plot.")
        return

    # Use fixed order: promoter, then gene_body
    region_order = ["Promoter Peaks", "Gene Body Peaks"]
    subset_df["region_label"] = pd.Categorical(
        subset_df["region_label"], categories=region_order, ordered=True
    )
    subset_df = subset_df.sort_values("region_label")
    x_positions = np.arange(len(subset_df))
    lower_err = (
        subset_df["correlation_log2_ratio_abs"] - subset_df["fisher_ci_lower"]
    ).clip(lower=0).fillna(0.0)
    upper_err = (
        subset_df["fisher_ci_upper"] - subset_df["correlation_log2_ratio_abs"]
    ).clip(lower=0).fillna(0.0)
    yerr = np.vstack([lower_err.to_numpy(), upper_err.to_numpy()])

    fig, ax = plt.subplots(figsize=(10, 6))
    bars = ax.bar(
        x_positions,
        subset_df["correlation_log2_ratio_abs"],
        yerr=yerr,
        capsize=5,
        alpha=0.8,
        edgecolor="black",
    )

    # Color bars by significance
    for i, (_, row) in enumerate(subset_df.iterrows()):
        if row["pvalue_log2_ratio_abs"] < 0.05:
            bars[i].set_color("steelblue")
        else:
            bars[i].set_color("lightgray")

    ax.axhline(0, color="black", linewidth=0.8, linestyle="--")
    ax.set_xticks(x_positions)
    ax.set_xticklabels(subset_df["region_label"], rotation=45, ha="right")
    ax.set_ylabel(f"Correlation ({results_df['correlation_method'].iloc[0].capitalize()})")
    ax.set_title(
        f"Peak-Based MeCP2 Enrichment vs Absolute Expression Change\n"
        f"(DEA genes with significant MeCP2 enrichment, {int(alpha * 100)}% CI)"
    )
    ax.grid(axis="y", alpha=0.3)

    plt.tight_layout()
    output_path = output_dir / f"peak_correlation_summary_{suffix}.png"
    plt.savefig(output_path, dpi=300, bbox_inches="tight")
    plt.close()
    logging.info(f"Saved correlation summary plot to {output_path}")


def create_scatter_plots(
    scatter_data: Dict[str, pd.DataFrame],
    method: str,
    output_dir: Path,
    suffix: str,
    log2fc_outlier_threshold: float = 15.0,
) -> None:
    """Create scatter plots for each peak region type"""
    n_regions = len(scatter_data)
    if n_regions == 0:
        return

    fig, axes = plt.subplots(1, n_regions, figsize=(6 * n_regions, 5))
    if n_regions == 1:
        axes = [axes]

    # Use fixed order: promoter, then gene_body
    region_order = ["promoter", "gene_body"]
    ordered_items = [(rt, scatter_data[rt]) for rt in region_order if rt in scatter_data]

    for ax, (region_type, df) in zip(axes, ordered_items):
        log2_ratio_col = f'{region_type}_log2_ratio'

        # Use absolute log2FoldChange
        x = df[log2_ratio_col]
        y = df['abs_log2FoldChange']

        # Remove inf/nan
        valid = np.isfinite(x) & np.isfinite(y)
        x_valid = x[valid]
        y_valid = y[valid]

        # Filter outliers: remove extreme values from both axes
        # Filter y-axis (expression log2FC)
        y_outlier_filter = (y_valid <= log2fc_outlier_threshold) & (y_valid >= -log2fc_outlier_threshold)
        # Filter x-axis (log2 ratio of exo/endo signals) - use same threshold for consistency
        x_outlier_filter = (x_valid <= log2fc_outlier_threshold) & (x_valid >= -log2fc_outlier_threshold)
        
        # Apply both filters
        combined_filter = y_outlier_filter & x_outlier_filter
        x_filtered = x_valid[combined_filter]
        y_filtered = y_valid[combined_filter]
        
        n_outliers = len(y_valid) - len(y_filtered)
        if n_outliers > 0:
            logging.info(f"Filtered {n_outliers} outliers with |log2FC| > {log2fc_outlier_threshold} or |log2 ratio| > {log2fc_outlier_threshold} for {region_type} region")

        if len(x_filtered) < 3:
            ax.text(0.5, 0.5, "Insufficient data", ha='center', va='center', transform=ax.transAxes)
            ax.set_title(PEAK_REGION_CATEGORIES[region_type])
            continue

        # Scatter plot
        ax.scatter(x_filtered, y_filtered, alpha=0.5, s=20, edgecolors='none')

        # Regression line
        if len(x_filtered) >= 3:
            slope, intercept, r_value, p_value, std_err = stats.linregress(x_filtered, y_filtered)
            x_line = np.linspace(x_filtered.min(), x_filtered.max(), 100)
            y_line = slope * x_line + intercept
            ax.plot(x_line, y_line, 'r-', linewidth=2,
                   label=f'RÂ²={r_value**2:.3f}, p={p_value:.2e}')

        ax.axvline(0, color='gray', linestyle='--', alpha=0.5)
        ax.set_xlabel('log2(Exo/Endo Signal) from Peaks')
        ax.set_ylabel('|log2 Fold Change| (Expression)')
        ax.set_title(f"{PEAK_REGION_CATEGORIES[region_type]} (outliers removed)")
        ax.legend()
        ax.grid(alpha=0.3)

    plt.tight_layout()
    output_path = output_dir / f"peak_scatter_plots_{suffix}.png"
    plt.savefig(output_path, dpi=300, bbox_inches="tight")
    plt.close()
    logging.info(f"Saved scatter plots to {output_path}")


def main():
    parser = argparse.ArgumentParser(
        description="Peak-Based MeCP2 Enrichment vs Gene Expression Correlation (DEA + significant enrichment only)"
    )
    parser.add_argument(
        "--peak-enrichment-file",
        type=Path,
        required=True,
        help="Annotated peak enrichment detailed CSV file (e.g., peak_enrichment_detailed_raw_Neu_annotated.csv)"
    )
    parser.add_argument(
        "--dea-filtered-file",
        type=Path,
        required=True,
        help="DEA filtered genes CSV file"
    )
    parser.add_argument(
        "--output-dir",
        type=Path,
        required=True,
        help="Output directory for results"
    )
    parser.add_argument(
        "--cell-type",
        type=str,
        required=True,
        help="Cell type (e.g., Neu, NSC)"
    )
    parser.add_argument(
        "--normalization-method",
        type=str,
        default="raw",
        choices=["raw", "quantile", "ratio", "reference"],
        help="Normalization method to use (must match peak_based_enrichment_analysis.py output)"
    )
    parser.add_argument(
        "--correlation-method",
        type=str,
        default="spearman",
        choices=["pearson", "spearman"],
        help="Correlation method"
    )
    parser.add_argument(
        "--min-genes",
        type=int,
        default=50,
        help="Minimum number of genes required for correlation analysis"
    )
    parser.add_argument(
        "--alpha",
        type=float,
        default=0.05,
        help="Alpha level for confidence intervals"
    )
    parser.add_argument(
        "--enrichment-pvalue-threshold",
        type=float,
        default=1.0,
        help="P-value threshold for MeCP2 enrichment (default 1.0 = no filtering). Use < 1.0 to enable p-value filtering."
    )
    parser.add_argument(
        "--enrichment-ratio-threshold",
        type=float,
        default=0.0,
        help="Exo/Endo mean signal ratio threshold (default 0.0 = no filtering). Use > 0.0 to filter by enrichment magnitude."
    )
    parser.add_argument(
        "--log2fc-outlier-threshold",
        type=float,
        default=15.0,
        help="Filter out genes with |log2FC| > threshold (default 15.0). Use to remove extreme outliers."
    )
    parser.add_argument(
        "--verbose",
        action="store_true",
        help="Enable verbose logging"
    )

    args = parser.parse_args()

    configure_logging(args.verbose)
    args.output_dir.mkdir(parents=True, exist_ok=True)

    logging.info("="*80)
    logging.info("Peak-Based MeCP2 Enrichment vs Expression Correlation Analysis")
    logging.info("="*80)
    logging.info(f"Peak enrichment file: {args.peak_enrichment_file}")
    logging.info(f"DEA file: {args.dea_filtered_file}")
    logging.info(f"Cell type: {args.cell_type}")
    logging.info(f"Normalization method: {args.normalization_method}")
    logging.info(f"Correlation method: {args.correlation_method}")
    logging.info(f"Enrichment p-value threshold: {args.enrichment_pvalue_threshold}")
    logging.info(f"Enrichment ratio threshold: {args.enrichment_ratio_threshold}")
    logging.info(f"Output directory: {args.output_dir}")

    try:
        # Load data
        peak_enrichment_df = load_peak_enrichment_data(args.peak_enrichment_file)
        dea_df = load_dea_filtered_genes(args.dea_filtered_file)

        # Check if peaks have gene annotations
        if 'gene_id' not in peak_enrichment_df.columns:
            logging.error("Peak enrichment file lacks 'gene_id' column. Ensure annotate_peaks_with_regions.R was run.")
            sys.exit(1)

        # Aggregate peaks to gene level
        gene_level_df = aggregate_peaks_to_genes(peak_enrichment_df, args.normalization_method)

        # Merge with DEA and filter
        merged_df = merge_with_dea_and_filter(
            gene_level_df,
            dea_df,
            args.enrichment_pvalue_threshold,
            args.enrichment_ratio_threshold
        )

        # Compute enrichment metrics
        enrichment_df = compute_enrichment_metrics(merged_df)

        # Save intermediate merged dataset
        merged_output = args.output_dir / f"peak_based_integrated_dea_enrichment_{args.normalization_method}_{args.cell_type}.csv"
        enrichment_df.to_csv(merged_output, index=False)
        logging.info(f"Saved merged dataset to {merged_output}")

        # Compute correlations
        suffix = f"{args.normalization_method}_{args.cell_type}"
        results_df, scatter_data = compute_peak_region_correlations(
            enrichment_df,
            args.correlation_method,
            args.alpha,
            args.min_genes
        )

        if results_df.empty:
            logging.warning("No correlations computed. Check data and min_genes threshold.")
            sys.exit(0)

        # Save correlation results
        results_output = args.output_dir / f"peak_correlation_results_{suffix}.csv"
        results_df.to_csv(results_output, index=False)
        logging.info(f"Saved correlation results to {results_output}")

        # Create visualizations
        create_correlation_plot(results_df, args.alpha, args.output_dir, suffix)
        create_scatter_plots(scatter_data, args.correlation_method, args.output_dir, suffix, args.log2fc_outlier_threshold)

        # Print summary
        logging.info("\n" + "="*80)
        logging.info("CORRELATION SUMMARY")
        logging.info("="*80)

        summary_df = results_df[results_df['subset'] == 'all_dea'][
            ['region_label', 'n_genes', 'correlation_log2_ratio_abs',
             'pvalue_log2_ratio_abs', 'r_squared']
        ].copy()

        if not summary_df.empty:
            print(summary_df.to_string(index=False))
        else:
            logging.info("No summary available")

        logging.info("="*80)
        logging.info("Analysis completed successfully!")

    except Exception as e:
        logging.error(f"Analysis failed: {e}", exc_info=True)
        sys.exit(1)


if __name__ == "__main__":
    main()
